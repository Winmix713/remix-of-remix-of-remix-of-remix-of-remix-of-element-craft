```App.tsx
import { memo, lazy, Suspense } from "react";
import { Toaster } from "@/components/ui/toaster";
import { Toaster as Sonner } from "@/components/ui/sonner";
import { TooltipProvider } from "@/components/ui/tooltip";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
import { BrowserRouter, Routes, Route, Navigate } from "react-router-dom";
const Index = lazy(() => import("./pages/Index"));
const NotFound = lazy(() => import("./pages/NotFound"));
const QUERY_CLIENT_CONFIG = {
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5,
      cacheTime: 1000 * 60 * 10,
      refetchOnWindowFocus: false,
      refetchOnReconnect: true,
      retry: 1,
    },
    mutations: {
      retry: 1,
    },
  },
} as const;
const TOOLTIP_CONFIG = {
  delayDuration: 300,
  skipDelayDuration: 0,
} as const;
const queryClient = new QueryClient(QUERY_CLIENT_CONFIG);
interface RouteConfig {
  path: string;
  element: JSX.Element;
  protected?: boolean;
}
const routes: RouteConfig[] = [
  {
    path: "/",
    element: <Index />,
  },
];
const RouteLoadingFallback = memo(() => (
  <div className="min-h-screen flex items-center justify-center">
    <div className="w-6 h-6 border-2 border-primary border-t-transparent rounded-full animate-spin" />
  </div>
));
RouteLoadingFallback.displayName = "RouteLoadingFallback";
interface ProtectedRouteProps {
  children: JSX.Element;
}
const ProtectedRoute = memo<ProtectedRouteProps>(({ children }) => {
  const isAuthenticated = true;
  if (!isAuthenticated) {
    return <Navigate to="/" replace />;
  }
  return children;
});
ProtectedRoute.displayName = "ProtectedRoute";
interface AppProvidersProps {
  children: React.ReactNode;
}
const AppProviders = memo<AppProvidersProps>(({ children }) => (
  <QueryClientProvider client={queryClient}>
    <TooltipProvider {...TOOLTIP_CONFIG}>
      {children}
      <Toaster />
      <Sonner />
      {process.env.NODE_ENV === "development" && (
        <ReactQueryDevtools initialIsOpen={false} buttonPosition="bottom-right" />
      )}
    </TooltipProvider>
  </QueryClientProvider>
));
AppProviders.displayName = "AppProviders";
const AppRoutes = memo(() => (
  <Routes>
    {routes.map(({ path, element, protected: isProtected }) => (
      <Route
        key={path}
        path={path}
        element={
          <Suspense fallback={<RouteLoadingFallback />}>
            {isProtected ? <ProtectedRoute>{element}</ProtectedRoute> : element}
          </Suspense>
        }
      />
    ))}
    <Route
      path="*"
      element={
        <Suspense fallback={<RouteLoadingFallback />}>
          <NotFound />
        </Suspense>
      }
    />
  </Routes>
));
AppRoutes.displayName = "AppRoutes";
const App = memo(() => (
  <AppProviders>
    <BrowserRouter>
      <AppRoutes />
    </BrowserRouter>
  </AppProviders>
));
App.displayName = "App";
export default App;

```
```pages/Index.tsx
import { ThemeProvider, EffectProvider } from "@/contexts/ThemeContext";
import { SelectionProvider } from "@/contexts/SelectionContext";
import { MultiEffectEditor } from "@/components/MultiEffectEditor";
import { EffectEditorTabs } from "@/components/EffectEditorTabs";
import { PhonePreview } from "@/components/PhonePreview";
import { ThemeCustomizer } from "@/components/ThemeCustomizer";
import { PropertyInspector } from "@/components/PropertyInspector";
import { PresetsGallery } from "@/components/PresetsGallery";
import { ExportPanel } from "@/components/ExportPanel";
import { QuickActionsPanel } from "@/components/QuickActionsPanel";
import { useState } from "react";
import { Settings, Layers, Sparkles, Code, Zap } from "lucide-react";
import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { ScrollArea } from "@/components/ui/scroll-area";
type RightPanel = 'actions' | 'theme' | 'inspector' | 'presets' | 'export';
const Index = () => {
  const [rightPanel, setRightPanel] = useState<RightPanel>('presets');
  return (
    <ThemeProvider>
      <EffectProvider>
        <SelectionProvider>
        <div className="min-h-screen w-full bg-background text-foreground antialiased font-outfit">
          <div className="fixed inset-0 bg-gradient-to-br from-background via-background to-violet/5 pointer-events-none" />
          <div className="fixed inset-0 bg-[radial-gradient(ellipse_at_top,_var(--tw-gradient-stops))] from-violet/10 via-transparent to-transparent pointer-events-none" />
          <div className="relative w-full h-screen flex">
            <section className="w-1/2 h-full p-4 overflow-hidden flex flex-col">
              <div className="relative flex-1 rounded-3xl border border-border/80 bg-card/80 shadow-[0_0_0_1px_rgba(255,255,255,0.02),0_22px_60px_rgba(0,0,0,0.9)] backdrop-blur-xl overflow-hidden flex flex-col">
                <div className="flex items-center justify-between px-5 sm:px-6 pt-4 sm:pt-5 pb-4 border-b border-border/70">
                  <div className="flex items-center gap-2.5">
                    <div className="flex items-center gap-1.5">
                      <span className="h-2.5 w-2.5 rounded-full bg-destructive/80" />
                      <span className="h-2.5 w-2.5 rounded-full bg-amber/80" />
                      <span className="h-2.5 w-2.5 rounded-full bg-emerald/80" />
                    </div>
                    <div className="h-4 w-px bg-border ml-2" />
                    <div>
                      <p className="text-sm font-semibold tracking-tight text-foreground">Multi‑Effect Editor</p>
                      <p className="text-sm text-muted-foreground mt-0.5">Fények, árnyékok és hangulatok valós idejű finomhangolása</p>
                    </div>
                  </div>
                </div>
                <div className="flex-1 flex flex-col lg:flex-row gap-5 sm:gap-6 px-5 sm:px-6 pb-5 sm:pb-6 pt-4 sm:pt-5 overflow-auto">
                  <div className="w-full lg:w-[40%]"><MultiEffectEditor /></div>
                  <div className="w-full lg:w-[60%]"><EffectEditorTabs /></div>
                </div>
                <div className="flex items-center justify-between px-5 sm:px-6 py-3 border-t border-border/80 bg-card/90">
                  <div className="flex items-center gap-2 text-xs text-muted-foreground">
                    <span className="inline-flex h-4 w-4 items-center justify-center rounded-full bg-secondary border border-border/80">
                      <Settings className="h-2.5 w-2.5 text-muted-foreground" />
                    </span>
                    <span className="tracking-tight">Ctrl+Z / Ctrl+Y a visszavonáshoz/újra</span>
                  </div>
                  <div className="flex items-center gap-1.5 text-xs text-primary">
                    <Sparkles className="w-3 h-3" />
                    <span className="font-medium">Effect Studio</span>
                  </div>
                </div>
              </div>
            </section>
            <section className="w-1/2 h-full p-4 overflow-hidden flex flex-col gap-4">
              <Tabs value={rightPanel} onValueChange={(v) => setRightPanel(v as RightPanel)} className="w-full">
                <TabsList className="w-full bg-secondary/50 border border-border/80 grid grid-cols-5">
                  <TabsTrigger value="actions" className="gap-1 data-[state=active]:bg-primary/20 data-[state=active]:text-primary"><Zap className="w-3.5 h-3.5" /><span className="text-xs">Műveletek</span></TabsTrigger>
                  <TabsTrigger value="presets" className="gap-1 data-[state=active]:bg-primary/20 data-[state=active]:text-primary"><Sparkles className="w-3.5 h-3.5" /><span className="text-xs">Presetek</span></TabsTrigger>
                  <TabsTrigger value="theme" className="gap-1 data-[state=active]:bg-primary/20 data-[state=active]:text-primary"><Settings className="w-3.5 h-3.5" /><span className="text-xs">Téma</span></TabsTrigger>
                  <TabsTrigger value="inspector" className="gap-1 data-[state=active]:bg-primary/20 data-[state=active]:text-primary"><Layers className="w-3.5 h-3.5" /><span className="text-xs">Vizsgáló</span></TabsTrigger>
                  <TabsTrigger value="export" className="gap-1 data-[state=active]:bg-primary/20 data-[state=active]:text-primary"><Code className="w-3.5 h-3.5" /><span className="text-xs">Exportálás</span></TabsTrigger>
                </TabsList>
              </Tabs>
              <div className="flex-1 flex gap-4 overflow-hidden">
                <div className="flex items-center justify-center"><PhonePreview /></div>
                <div className="flex-1 rounded-2xl border border-border/80 bg-card/80 backdrop-blur-xl p-4 shadow-lg overflow-hidden">
                  <ScrollArea className="h-full pr-2">
                    {rightPanel === 'actions' && <QuickActionsPanel />}
                    {rightPanel === 'presets' && <PresetsGallery />}
                    {rightPanel === 'theme' && <ThemeCustomizer />}
                    {rightPanel === 'inspector' && <PropertyInspector />}
                    {rightPanel === 'export' && <ExportPanel />}
                  </ScrollArea>
                </div>
              </div>
            </section>
          </div>
        </div>
        </SelectionProvider>
      </EffectProvider>
    </ThemeProvider>
  );
};
export default Index;

```
```contexts/ThemeContext.tsx
import React, { createContext, useContext, useState, useCallback, useMemo, useEffect, ReactNode } from 'react';
import { HistoryState, pushToHistory, undoHistory, redoHistory, jumpToHistory, useKeyboardShortcuts } from '@/hooks/useHistory';
export type EffectType = 'glow' | 'glass' | 'neomorph' | 'clay';
export type ThemeModeType = 'dark' | 'light' | 'auto';
export type GlowAnimationType = 'none' | 'pulse' | 'breathe' | 'wave';
export type ShapeType = 'flat' | 'concave' | 'convex' | 'pressed';
export type SurfaceTexture = 'smooth' | 'matte' | 'glossy';
export type ThemeMode = 'light' | 'dark' | 'system';
export type ShapePreset = 'sharp' | 'rounded' | 'full';
export type SolidStyle = 'color' | 'inverse' | 'contrast';
export type EffectStyle = 'flat' | 'plastic';
export type SurfaceStyle = 'filled' | 'translucent';
export type DataStyle = 'categorical' | 'divergent' | 'sequential';
export type TransitionStyle = 'all' | 'micro' | 'macro' | 'none';
export interface GlowSettings {
  lightness: number;
  chroma: number;
  hue: number;
  baseColor: string;
  animation: GlowAnimationType;
  animationSpeed: number;
  animationIntensity: number;
  maskSize: number;
  glowScale: number;
  noiseEnabled: boolean;
  noiseIntensity: number;
}
export interface BlurSettings {
  x: number;
  y: number;
}
export interface GlassSettings {
  blur: number;
  opacity: number;
  saturation: number;
  borderWidth: number;
  borderOpacity: number;
  tint: string;
  tintStrength: number;
}
export interface NeomorphSettings {
  distance: number;
  blur: number;
  intensity: number;
  shape: ShapeType;
  lightSource: number;
  surfaceColor: string;
}
export type ShadowDirection = 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
export interface ClaySettings {
  depth: number;
  spread: number;
  borderRadius: number;
  highlightColor: string;
  shadowColor: string;
  surfaceTexture: SurfaceTexture;
  bendAngle: number;
  opacity?: number;
  blur?: number;
  shadowDirection?: ShadowDirection;
}
export interface EffectState {
  powerOn: boolean;
  activeEffects: Record<EffectType, boolean>;
  themeMode: ThemeModeType;
  glowSettings: GlowSettings;
  blurSettings: BlurSettings;
  glassSettings: GlassSettings;
  neomorphSettings: NeomorphSettings;
  claySettings: ClaySettings;
}
export interface ThemeConfig {
  mode: ThemeMode;
  shape: ShapePreset;
  colors: { primary: string; accent: string; neutral: 'slate' | 'gray' | 'zinc'; };
  solidStyle: SolidStyle;
  effectStyle: EffectStyle;
  surface: SurfaceStyle;
  scaling: number;
  dataStyle: DataStyle;
  transition: TransitionStyle;
  borderWidth: number;
  depthEffect: boolean;
  noiseEffect: boolean;
  fieldBaseSize: number;
  selectorBaseSize: number;
}
interface EffectContextType {
  state: EffectState;
  togglePower: () => void;
  toggleEffect: (effect: EffectType) => void;
  setThemeMode: (mode: ThemeModeType) => void;
  updateGlowSettings: (settings: Partial<GlowSettings>) => void;
  updateBlurSettings: (settings: Partial<BlurSettings>) => void;
  updateGlassSettings: (settings: Partial<GlassSettings>) => void;
  updateNeomorphSettings: (settings: Partial<NeomorphSettings>) => void;
  updateClaySettings: (settings: Partial<ClaySettings>) => void;
  resetBlurPosition: () => void;
  resetToDefaults: () => void;
  getActiveEffectsCount: () => number;
  getOklchColor: () => string;
  generateCSS: () => string;
  exportState: () => string;
  importState: (jsonString: string) => boolean;
  history: HistoryState<EffectState>;
  undo: () => void;
  redo: () => void;
  canUndo: boolean;
  canRedo: boolean;
  jumpToHistoryEntry: (id: string) => void;
  clearHistory: () => void;
}
interface ThemeContextType {
  theme: ThemeConfig;
  updateTheme: (updates: Partial<ThemeConfig>) => void;
  resetTheme: () => void;
}
const STORAGE_KEY = 'effect-editor';
const THEME_STORAGE_KEY = 'theme-customizer';
const DEFAULT_BLUR_X = -590;
const DEFAULT_BLUR_Y = -1070;
const defaultGlowSettings: GlowSettings = {
  lightness: 78, chroma: 0.18, hue: 70, baseColor: '#FF9F00', animation: 'none', animationSpeed: 2, animationIntensity: 50, maskSize: 0.3, glowScale: 0.9, noiseEnabled: true, noiseIntensity: 0.35,
};
const defaultBlurSettings: BlurSettings = { x: DEFAULT_BLUR_X, y: DEFAULT_BLUR_Y };
const defaultGlassSettings: GlassSettings = { blur: 12, opacity: 20, saturation: 120, borderWidth: 1, borderOpacity: 20, tint: '#ffffff', tintStrength: 10 };
const defaultNeomorphSettings: NeomorphSettings = { distance: 10, blur: 30, intensity: 50, shape: 'flat', lightSource: 145, surfaceColor: '#2a2a2a' };
const defaultClaySettings: ClaySettings = { depth: 10, spread: 10, borderRadius: 24, highlightColor: '#ffffff', shadowColor: '#000000', surfaceTexture: 'smooth', bendAngle: 0, opacity: 100, blur: 20, shadowDirection: 'bottom-right' };
export const defaultEffectState: EffectState = {
  powerOn: true,
  activeEffects: { glow: true, glass: false, neomorph: false, clay: false },
  themeMode: 'dark',
  glowSettings: defaultGlowSettings,
  blurSettings: defaultBlurSettings,
  glassSettings: defaultGlassSettings,
  neomorphSettings: defaultNeomorphSettings,
  claySettings: defaultClaySettings,
};
export const defaultThemeConfig: ThemeConfig = {
  mode: 'dark', shape: 'rounded', colors: { primary: '217 91% 60%', accent: '280 85% 65%', neutral: 'slate' }, solidStyle: 'color', effectStyle: 'flat', surface: 'filled', scaling: 100, dataStyle: 'categorical', transition: 'all', borderWidth: 1, depthEffect: false, noiseEffect: false, fieldBaseSize: 4, selectorBaseSize: 4,
};
const EffectContext = createContext<EffectContextType | undefined>(undefined);
const ThemeContext = createContext<ThemeContextType | undefined>(undefined);
const loadStateFromStorage = (): EffectState => {
  try { const stored = localStorage.getItem(STORAGE_KEY); if (!stored) return defaultEffectState; const parsed = JSON.parse(stored); return { ...defaultEffectState, ...parsed }; } catch { return defaultEffectState; }
};
const saveStateToStorage = (state: EffectState): void => { try { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); } catch {} };
const clamp = (value: number, min: number, max: number): number => Math.min(Math.max(value, min), max);
const formatOklch = (lightness: number, chroma: number, hue: number): string => { const l = clamp(lightness, 0, 100) / 100; const c = clamp(chroma, 0, 0.4); const h = hue % 360; return `oklch(${l.toFixed(2)} ${c.toFixed(3)} ${h})`; };
export const EffectProvider = ({ children }: { children: ReactNode }) => {
  const [historyState, setHistoryState] = useState<HistoryState<EffectState>>(() => ({ past: [], present: loadStateFromStorage(), future: [] }));
  const state = historyState.present;
  useEffect(() => { saveStateToStorage(state); }, [state]);
  const pushHistory = useCallback((newState: EffectState, label: string) => { setHistoryState(prev => pushToHistory(prev, newState, label)); }, []);
  const undo = useCallback(() => { setHistoryState(prev => undoHistory(prev) || prev); }, []);
  const redo = useCallback(() => { setHistoryState(prev => redoHistory(prev) || prev); }, []);
  const canUndo = historyState.past.length > 0;
  const canRedo = historyState.future.length > 0;
  useKeyboardShortcuts(undo, redo, canUndo, canRedo);
  const jumpToHistoryEntry = useCallback((id: string) => { setHistoryState(prev => jumpToHistory(prev, id) || prev); }, []);
  const clearHistory = useCallback(() => { setHistoryState(prev => ({ past: [], present: prev.present, future: [] })); }, []);
  const togglePower = useCallback(() => { const newState = { ...state, powerOn: !state.powerOn }; pushHistory(newState, `Power ${newState.powerOn ? 'on' : 'off'}`); }, [state, pushHistory]);
  const toggleEffect = useCallback((effect: EffectType) => { const newActiveState = !state.activeEffects[effect]; const newState = { ...state, activeEffects: { ...state.activeEffects, [effect]: newActiveState } }; pushHistory(newState, `${effect} ${newActiveState ? 'enabled' : 'disabled'}`); }, [state, pushHistory]);
  const setThemeMode = useCallback((mode: ThemeModeType) => { if (state.themeMode === mode) return; const newState = { ...state, themeMode: mode }; pushHistory(newState, `Theme: ${mode}`); }, [state, pushHistory]);
  const updateGlowSettings = useCallback((settings: Partial<GlowSettings>) => { const newState = { ...state, glowSettings: { ...state.glowSettings, ...settings } }; pushHistory(newState, 'Glow changed'); }, [state, pushHistory]);
  const updateBlurSettings = useCallback((settings: Partial<BlurSettings>) => { const newState = { ...state, blurSettings: { ...state.blurSettings, ...settings } }; pushHistory(newState, 'Blur changed'); }, [state, pushHistory]);
  const updateGlassSettings = useCallback((settings: Partial<GlassSettings>) => { const newState = { ...state, glassSettings: { ...state.glassSettings, ...settings } }; pushHistory(newState, 'Glass changed'); }, [state, pushHistory]);
  const updateNeomorphSettings = useCallback((settings: Partial<NeomorphSettings>) => { const newState = { ...state, neomorphSettings: { ...state.neomorphSettings, ...settings } }; pushHistory(newState, 'Neomorph changed'); }, [state, pushHistory]);
  const updateClaySettings = useCallback((settings: Partial<ClaySettings>) => { const newState = { ...state, claySettings: { ...state.claySettings, ...settings } }; pushHistory(newState, 'Clay changed'); }, [state, pushHistory]);
  const resetBlurPosition = useCallback(() => { const newState = { ...state, blurSettings: { ...defaultBlurSettings } }; pushHistory(newState, 'Blur reset'); }, [state, pushHistory]);
  const resetToDefaults = useCallback(() => { pushHistory(defaultEffectState, 'Reset to defaults'); }, [pushHistory]);
  const getActiveEffectsCount = useCallback((): number => Object.values(state.activeEffects).filter(Boolean).length, [state.activeEffects]);
  const getOklchColor = useCallback((): string => formatOklch(state.glowSettings.lightness, state.glowSettings.chroma, state.glowSettings.hue), [state.glowSettings]);
  const generateCSS = useCallback((): string => { const oklch = getOklchColor(); const { x, y } = state.blurSettings; return `.glow-effect { background-color: ${oklch}; filter: blur(180px); }\n.phone-preview { --glow-color: ${oklch}; --blur-x: ${x}px; --blur-y: ${y}px; }`; }, [getOklchColor, state.blurSettings]);
  const exportState = useCallback((): string => JSON.stringify(state, null, 2), [state]);
  const importState = useCallback((jsonString: string): boolean => { try { const parsed = JSON.parse(jsonString); const newState = { ...defaultEffectState, ...parsed }; pushHistory(newState, 'State imported'); return true; } catch { return false; } }, [pushHistory]);
  const contextValue = useMemo<EffectContextType>(() => ({ state, togglePower, toggleEffect, setThemeMode, updateGlowSettings, updateBlurSettings, updateGlassSettings, updateNeomorphSettings, updateClaySettings, resetBlurPosition, resetToDefaults, getActiveEffectsCount, getOklchColor, generateCSS, exportState, importState, history: historyState, undo, redo, canUndo, canRedo, jumpToHistoryEntry, clearHistory }), [state, togglePower, toggleEffect, setThemeMode, updateGlowSettings, updateBlurSettings, updateGlassSettings, updateNeomorphSettings, updateClaySettings, resetBlurPosition, resetToDefaults, getActiveEffectsCount, getOklchColor, generateCSS, exportState, importState, historyState, undo, redo, canUndo, canRedo, jumpToHistoryEntry, clearHistory]);
  return <EffectContext.Provider value={contextValue}>{children}</EffectContext.Provider>;
};
export const ThemeProvider = ({ children }: { children: ReactNode }) => {
  const [theme, setTheme] = useState<ThemeConfig>(() => { try { const stored = localStorage.getItem(THEME_STORAGE_KEY); if (stored) { const parsed = JSON.parse(stored); return { ...defaultThemeConfig, ...parsed, colors: { ...defaultThemeConfig.colors, ...(parsed.colors || {}) } }; } return defaultThemeConfig; } catch { localStorage.removeItem(THEME_STORAGE_KEY); return defaultThemeConfig; } });
  useEffect(() => { localStorage.setItem(THEME_STORAGE_KEY, JSON.stringify(theme)); }, [theme]);
  const updateTheme = useCallback((updates: Partial<ThemeConfig>) => { setTheme(prev => ({ ...prev, ...updates, colors: updates.colors ? { ...prev.colors, ...updates.colors } : prev.colors })); }, []);
  const resetTheme = useCallback(() => { setTheme(defaultThemeConfig); localStorage.removeItem(THEME_STORAGE_KEY); }, []);
  const value = useMemo(() => ({ theme, updateTheme, resetTheme }), [theme, updateTheme, resetTheme]);
  return <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>;
};
export const useEffects = (): EffectContextType => { const context = useContext(EffectContext); if (!context) throw new Error('useEffects must be used within EffectProvider'); return context; };
export const useTheme = (): ThemeContextType => { const context = useContext(ThemeContext); if (!context) { console.warn('useTheme must be used within ThemeProvider'); return { theme: defaultThemeConfig, updateTheme: () => {}, resetTheme: () => {} }; } return context; };
export const useEffectToggle = (effect: EffectType) => { const { state, toggleEffect } = useEffects(); return { isActive: state.activeEffects[effect], toggle: () => toggleEffect(effect) }; };
export const useGlowControls = () => { const { state, updateGlowSettings, getOklchColor } = useEffects(); return { settings: state.glowSettings, updateSettings: updateGlowSettings, oklchColor: getOklchColor() }; };
export const useBlurControls = () => { const { state, updateBlurSettings, resetBlurPosition } = useEffects(); return { settings: state.blurSettings, updateSettings: updateBlurSettings, reset: resetBlurPosition }; };

```
```contexts/SelectionContext.tsx
import React, { createContext, useContext, useState, useCallback, useMemo, ReactNode } from 'react';
export interface SelectedElement { id: string; type: string; tag: string; classes: string[]; styles: Record<string, string>; text?: string; parentId?: string; children?: string[]; }
export interface InspectorValues { marginX: number; marginY: number; paddingL: number; paddingT: number; paddingR: number; paddingB: number; position: 'static' | 'relative' | 'absolute' | 'fixed' | 'sticky'; positionL?: number; positionT?: number; positionR?: number; positionB?: number; width?: string; height?: string; opacity: number; bgColor: string | null; borderColor: string | null; textColor: string | null; borderRadius: number; blur: number; backdropBlur: number; brightness: number; saturation: number; hueRotate: number; grayscale: number; invert: number; translateX: number; translateY: number; rotate: number; scale: number; skewX: number; skewY: number; rotateX: number; rotateY: number; rotateZ: number; perspective: number; }
interface SelectionContextType { selectedElement: SelectedElement | null; inspectorValues: InspectorValues; selectElement: (element: SelectedElement | null) => void; updateInspectorValue: <K extends keyof InspectorValues>(key: K, value: InspectorValues[K]) => void; updateInspectorValues: (values: Partial<InspectorValues>) => void; resetInspectorValues: () => void; generateElementCSS: () => string; generateElementTailwind: () => string; }
const defaultInspectorValues: InspectorValues = { marginX: 0, marginY: 0, paddingL: 0, paddingT: 0, paddingR: 0, paddingB: 0, position: 'relative', opacity: 100, bgColor: null, borderColor: null, textColor: null, borderRadius: 0, blur: 0, backdropBlur: 0, brightness: 100, saturation: 100, hueRotate: 0, grayscale: 0, invert: 0, translateX: 0, translateY: 0, rotate: 0, scale: 100, skewX: 0, skewY: 0, rotateX: 0, rotateY: 0, rotateZ: 0, perspective: 0 };
const SelectionContext = createContext<SelectionContextType | undefined>(undefined);
export const SelectionProvider = ({ children }: { children: ReactNode }) => {
  const [selectedElement, setSelectedElement] = useState<SelectedElement | null>(null);
  const [inspectorValues, setInspectorValues] = useState<InspectorValues>(defaultInspectorValues);
  const selectElement = useCallback((element: SelectedElement | null) => { setSelectedElement(element); if (element?.styles) { const parsed: Partial<InspectorValues> = {}; if (element.styles.opacity) parsed.opacity = parseFloat(element.styles.opacity) * 100; if (element.styles.filter) { const blur = element.styles.filter.match(/blur\((\d+)px\)/); if (blur) parsed.blur = parseInt(blur[1]); } setInspectorValues(prev => ({ ...prev, ...parsed })); } }, []);
  const updateInspectorValue = useCallback(<K extends keyof InspectorValues>(key: K, value: InspectorValues[K]) => { setInspectorValues(prev => ({ ...prev, [key]: value })); }, []);
  const updateInspectorValues = useCallback((values: Partial<InspectorValues>) => { setInspectorValues(prev => ({ ...prev, ...values })); }, []);
  const resetInspectorValues = useCallback(() => { setInspectorValues(defaultInspectorValues); }, []);
  const generateElementCSS = useCallback((): string => { const v = inspectorValues; const lines: string[] = []; if (v.marginX || v.marginY) lines.push(`margin: ${v.marginY}px ${v.marginX}px;`); if (v.paddingL || v.paddingT || v.paddingR || v.paddingB) lines.push(`padding: ${v.paddingT}px ${v.paddingR}px ${v.paddingB}px ${v.paddingL}px;`); if (v.position !== 'static') lines.push(`position: ${v.position};`); if (v.width) lines.push(`width: ${v.width};`); if (v.height) lines.push(`height: ${v.height};`); if (v.opacity !== 100) lines.push(`opacity: ${v.opacity / 100};`); if (v.bgColor) lines.push(`background-color: ${v.bgColor};`); if (v.borderColor) lines.push(`border-color: ${v.borderColor};`); if (v.textColor) lines.push(`color: ${v.textColor};`); if (v.borderRadius) lines.push(`border-radius: ${v.borderRadius}px;`); const filters: string[] = []; if (v.blur) filters.push(`blur(${v.blur}px)`); if (v.brightness !== 100) filters.push(`brightness(${v.brightness}%)`); if (v.saturation !== 100) filters.push(`saturate(${v.saturation}%)`); if (v.hueRotate) filters.push(`hue-rotate(${v.hueRotate}deg)`); if (v.grayscale) filters.push(`grayscale(${v.grayscale}%)`); if (v.invert) filters.push(`invert(${v.invert}%)`); if (filters.length) lines.push(`filter: ${filters.join(' ')};`); if (v.backdropBlur) lines.push(`backdrop-filter: blur(${v.backdropBlur}px);`); const transforms: string[] = []; if (v.translateX || v.translateY) transforms.push(`translate(${v.translateX}px, ${v.translateY}px)`); if (v.rotate) transforms.push(`rotate(${v.rotate}deg)`); if (v.scale !== 100) transforms.push(`scale(${v.scale / 100})`); if (v.skewX) transforms.push(`skewX(${v.skewX}deg)`); if (v.skewY) transforms.push(`skewY(${v.skewY}deg)`); if (v.rotateX) transforms.push(`rotateX(${v.rotateX}deg)`); if (v.rotateY) transforms.push(`rotateY(${v.rotateY}deg)`); if (v.rotateZ) transforms.push(`rotateZ(${v.rotateZ}deg)`); if (transforms.length) { lines.push(`transform: ${transforms.join(' ')};`); if (v.perspective) lines.push(`perspective: ${v.perspective}px;`); } return `.element {\n  ${lines.join('\n  ')}\n}`; }, [inspectorValues]);
  const generateElementTailwind = useCallback((): string => { const v = inspectorValues; const classes: string[] = []; if (v.marginX) classes.push(`mx-${v.marginX}`); if (v.marginY) classes.push(`my-${v.marginY}`); if (v.paddingL) classes.push(`pl-${v.paddingL}`); if (v.paddingT) classes.push(`pt-${v.paddingT}`); if (v.paddingR) classes.push(`pr-${v.paddingR}`); if (v.paddingB) classes.push(`pb-${v.paddingB}`); if (v.position !== 'static') classes.push(v.position); if (v.opacity !== 100) classes.push(`opacity-${v.opacity}`); if (v.borderRadius) classes.push(`rounded-[${v.borderRadius}px]`); if (v.blur) classes.push(`blur-[${v.blur}px]`); if (v.backdropBlur) classes.push(`backdrop-blur-[${v.backdropBlur}px]`); if (v.brightness !== 100) classes.push(`brightness-${v.brightness}`); if (v.saturation !== 100) classes.push(`saturate-${v.saturation}`); if (v.grayscale) classes.push(`grayscale-${v.grayscale}`); if (v.invert) classes.push(`invert-${v.invert}`); if (v.hueRotate) classes.push(`hue-rotate-${v.hueRotate}`); if (v.translateX) classes.push(`translate-x-[${v.translateX}px]`); if (v.translateY) classes.push(`translate-y-[${v.translateY}px]`); if (v.rotate) classes.push(`rotate-[${v.rotate}deg]`); if (v.scale !== 100) classes.push(`scale-[${v.scale / 100}]`); if (v.skewX) classes.push(`skew-x-[${v.skewX}deg]`); if (v.skewY) classes.push(`skew-y-[${v.skewY}deg]`); return classes.join(' '); }, [inspectorValues]);
  const value = useMemo<SelectionContextType>(() => ({ selectedElement, inspectorValues, selectElement, updateInspectorValue, updateInspectorValues, resetInspectorValues, generateElementCSS, generateElementTailwind }), [selectedElement, inspectorValues, selectElement, updateInspectorValue, updateInspectorValues, resetInspectorValues, generateElementCSS, generateElementTailwind]);
  return <SelectionContext.Provider value={value}>{children}</SelectionContext.Provider>;
};
export const useSelection = (): SelectionContextType => { const context = useContext(SelectionContext); if (!context) throw new Error('useSelection must be used within SelectionProvider'); return context; };

```
```components/MultiEffectEditor.tsx
import { useEffects, EffectType } from '@/contexts/ThemeContext';
import { Sparkles, GlassWater, Layers, Palette, Sun, Moon, ChevronDown } from 'lucide-react';
import { cn } from '@/lib/utils';
import { useMemo, useCallback } from 'react';
interface EffectConfig { type: EffectType; label: string; description: string; icon: typeof Sparkles; color: string; }
const effectConfig: EffectConfig[] = [
  { type: 'glow', label: 'Glow', description: 'Meleg fókuszpont, puha peremekkel.', icon: Sparkles, color: 'amber' },
  { type: 'glass', label: 'Glass', description: 'Lágy üveg hatás, háttér-elmosással.', icon: GlassWater, color: 'sky' },
  { type: 'neomorph', label: 'Neomorph', description: 'Minimál domborítás, extra mélységgel.', icon: Layers, color: 'purple' },
  { type: 'clay', label: 'Clay', description: 'Meleg, plasztikus komponensek.', icon: Palette, color: 'rose' },
];
const colorClasses: Record<string, { bg: string; text: string; glow: string; gradient: string; border: string }> = {
  amber: { bg: 'bg-amber-400/15', text: 'text-amber-300', glow: 'shadow-[0_0_30px_rgba(251,191,36,0.6)]', gradient: 'from-amber-500/80 via-amber-400/80 to-amber-300/80', border: 'border-amber-500/50' },
  sky: { bg: 'bg-sky-400/15', text: 'text-sky-300', glow: 'shadow-[0_0_30px_rgba(56,189,248,0.6)]', gradient: 'from-sky-500/80 via-sky-400/80 to-sky-300/80', border: 'border-sky-500/50' },
  purple: { bg: 'bg-purple-400/15', text: 'text-purple-300', glow: 'shadow-[0_0_30px_rgba(192,132,252,0.6)]', gradient: 'from-purple-500/80 via-purple-400/80 to-purple-300/80', border: 'border-purple-500/50' },
  rose: { bg: 'bg-rose-400/15', text: 'text-rose-300', glow: 'shadow-[0_0_30px_rgba(251,113,133,0.6)]', gradient: 'from-rose-500/80 via-rose-400/80 to-rose-300/80', border: 'border-rose-500/50' },
};
export const MultiEffectEditor = () => {
  const { state, toggleEffect, getActiveEffectsCount } = useEffects();
  const activeCount = getActiveEffectsCount();
  const handleToggle = useCallback((type: EffectType) => { toggleEffect(type); }, [toggleEffect]);
  const EffectButton = useMemo(() => {
    return ({ config }: { config: EffectConfig }) => {
      const { type, label, description, icon: Icon, color } = config;
      const isActive = state.activeEffects[type];
      const colors = colorClasses[color];
      return (
        <button onClick={() => handleToggle(type)} className={cn("group w-full flex items-center justify-between rounded-xl transition-all duration-300", isActive ? `bg-gradient-to-r ${colors.gradient} p-[1px] ${colors.glow}` : "border border-neutral-800/80 bg-neutral-900/80 hover:bg-neutral-800/70 hover:border-neutral-700")} aria-pressed={isActive}>
          <div className={cn("flex-1 flex items-center justify-between px-3 py-2.5 transition-all", isActive && "rounded-[0.70rem] bg-neutral-950/95")}>
            <div className="flex items-center gap-2.5">
              <span className={cn("inline-flex h-6 w-6 items-center justify-center rounded-lg transition-all duration-300", colors.bg, colors.text, isActive && "scale-110")}><Icon className="h-3.5 w-3.5" /></span>
              <div className="text-left"><p className="text-xs font-semibold tracking-tight text-slate-100">{label}</p><p className={cn("text-xs transition-colors", isActive ? colors.text.replace('300', '100/90') : "text-slate-400")}>{description}</p></div>
            </div>
            <div className={cn("relative inline-flex h-5 w-10 items-center rounded-full transition-all duration-300", isActive ? colors.bg.replace('/15', '') : "bg-neutral-700")}><span className={cn("inline-block h-4 w-4 rounded-full bg-neutral-950 shadow-lg transition-transform duration-300", isActive ? "translate-x-5" : "translate-x-0.5")} /></div>
          </div>
        </button>
      );
    };
  }, [state.activeEffects, handleToggle]);
  return (
    <div className="w-full flex flex-col gap-4">
      <section className="rounded-2xl bg-neutral-900/60 border border-neutral-800/80 p-4">
        <div className="flex items-center justify-between mb-3">
          <div><h2 className="text-sm font-semibold tracking-tight text-slate-100">Aktív effektek</h2><p className="text-sm text-slate-400 mt-0.5">Kapcsold be a kívánt kombinációt.</p></div>
          <span className="inline-flex items-center gap-1.5 rounded-full bg-neutral-800/80 px-2.5 py-1"><Sun className="h-3.5 w-3.5 text-amber-400" /><span className="text-xs text-amber-200 tracking-tight font-medium">{activeCount} aktív</span></span>
        </div>
        <div className="space-y-1.5">{effectConfig.map((config) => (<EffectButton key={config.type} config={config} />))}</div>
      </section>
      <section className="rounded-2xl bg-neutral-900/70 border border-neutral-800/80 p-4">
        <div className="flex items-center justify-between mb-3">
          <div><h2 className="text-sm font-semibold tracking-tight text-slate-100">Téma mód</h2><p className="text-sm text-slate-400 mt-0.5">Szenáriók váltása egy kattintással.</p></div>
          <span className="inline-flex items-center gap-1 rounded-full bg-neutral-800/90 px-2 py-1"><Moon className="h-3.5 w-3.5 text-slate-300" /><span className="text-xs text-slate-200 tracking-tight font-medium">Auto-adaptive</span></span>
        </div>
        <button className="flex w-full items-center justify-between rounded-xl border border-neutral-700/80 bg-neutral-950/80 px-3.5 py-2.5 hover:border-neutral-500/80 transition-all">
          <div className="flex items-center gap-2.5"><span className="inline-flex h-6 w-6 items-center justify-center rounded-lg bg-slate-100 text-neutral-900"><Sun className="h-3.5 w-3.5" /></span><div className="text-left"><p className="text-xs font-semibold tracking-tight text-slate-100">Sötét mód · Glow fókusz</p><p className="text-xs text-slate-400">Ideális kontraszt prezentációkhoz.</p></div></div>
          <ChevronDown className="h-3.5 w-3.5 text-slate-400" />
        </button>
      </section>
    </div>
  );
};

```
```components/PhonePreview.tsx
import { useEffects } from '@/contexts/ThemeContext';
import { Move, Smartphone, LayoutDashboard, User, CreditCard, Shuffle } from 'lucide-react';
import Draggable from 'react-draggable';
import { useRef, useState, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { OnboardingTemplate, DashboardTemplate, ProfileTemplate, CardsTemplate, PreviewTemplate } from './PhonePreviewTemplates';
const templates: { id: PreviewTemplate; icon: React.ElementType; label: string }[] = [
  { id: 'onboarding', icon: Smartphone, label: 'Onboarding' },
  { id: 'dashboard', icon: LayoutDashboard, label: 'Dashboard' },
  { id: 'profile', icon: User, label: 'Profile' },
  { id: 'cards', icon: CreditCard, label: 'Cards' },
];
const generateRandomColor = () => { const hue = Math.floor(Math.random() * 360); const lightness = 65 + Math.floor(Math.random() * 20); const chroma = 0.15 + Math.random() * 0.15; return { hue, lightness, chroma }; };
export const PhonePreview = () => {
  const { state, getOklchColor, updateBlurSettings, updateGlowSettings } = useEffects();
  const oklchColor = getOklchColor();
  const { x, y } = state.blurSettings;
  const nodeRef = useRef<HTMLDivElement>(null);
  const [isDragging, setIsDragging] = useState(false);
  const [activeTemplate, setActiveTemplate] = useState<PreviewTemplate>('onboarding');
  const noiseUrl = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='200' height='200'><filter id='n'><feTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='4' /></filter><rect width='100%' height='100%' filter='url(%23n)' /></svg>";
  const defaultX = -590; const defaultY = -1070;
  const dragX = x - defaultX; const dragY = y - defaultY;
  const handleDrag = (_: any, data: { x: number; y: number }) => { updateBlurSettings({ x: defaultX + data.x, y: defaultY + data.y }); };
  const handleRandomColor = useCallback(() => { const { hue, lightness, chroma } = generateRandomColor(); updateGlowSettings({ hue, lightness, chroma }); }, [updateGlowSettings]);
  const maskSize = state.glowSettings.maskSize ?? 0.3;
  const glowScale = state.glowSettings.glowScale ?? 0.9;
  const noiseEnabled = state.glowSettings.noiseEnabled ?? true;
  const noiseIntensity = state.glowSettings.noiseIntensity ?? 0.35;
  const glassStyle = state.activeEffects.glass ? { backdropFilter: `blur(${state.glassSettings.blur}px) saturate(${state.glassSettings.saturation}%)`, backgroundColor: `${state.glassSettings.tint}${Math.round(state.glassSettings.opacity * 2.55).toString(16).padStart(2, '0')}`, border: `${state.glassSettings.borderWidth}px solid rgba(255,255,255,${state.glassSettings.borderOpacity / 100})` } : {};
  const getNeomorphShadow = () => { if (!state.activeEffects.neomorph) return {}; const { distance, blur, intensity, lightSource, surfaceColor, shape } = state.neomorphSettings; const angle = (lightSource * Math.PI) / 180; const lightX = Math.round(Math.cos(angle) * distance); const lightY = Math.round(Math.sin(angle) * distance); const darkX = -lightX; const darkY = -lightY; const lightOpacity = intensity / 100 * 0.5; const darkOpacity = intensity / 100; let inset = ''; if (shape === 'pressed') inset = 'inset '; else if (shape === 'concave') inset = 'inset '; return { backgroundColor: surfaceColor, boxShadow: `${inset}${lightX}px ${lightY}px ${blur}px rgba(255,255,255,${lightOpacity}), ${inset}${darkX}px ${darkY}px ${blur}px rgba(0,0,0,${darkOpacity})` }; };
  const getClayStyle = () => { if (!state.activeEffects.clay) return {}; const { depth, spread, borderRadius, highlightColor, shadowColor, surfaceTexture, bendAngle } = state.claySettings; let gradient = ''; switch (surfaceTexture) { case 'glossy': gradient = `linear-gradient(${135 + bendAngle}deg, ${highlightColor}40 0%, transparent 50%, ${shadowColor}20 100%)`; break; case 'matte': gradient = `linear-gradient(${135 + bendAngle}deg, ${highlightColor}20 0%, transparent 100%)`; break; default: gradient = `linear-gradient(${135 + bendAngle}deg, ${highlightColor}30 0%, transparent 60%, ${shadowColor}10 100%)`; } return { borderRadius: `${borderRadius}px`, boxShadow: `0 ${depth}px ${spread}px ${shadowColor}60, 0 ${depth * 0.5}px ${spread * 0.5}px ${shadowColor}40`, background: gradient }; };
  const renderTemplate = () => { const templateProps = { getNeomorphShadow, getClayStyle }; switch (activeTemplate) { case 'dashboard': return <DashboardTemplate {...templateProps} />; case 'profile': return <ProfileTemplate {...templateProps} />; case 'cards': return <CardsTemplate {...templateProps} />; default: return <OnboardingTemplate {...templateProps} />; } };
  const glowVariants = { initial: { opacity: 0, scale: 0.8 }, animate: { opacity: isDragging ? 0.7 : (state.glowSettings.animationIntensity / 100), scale: glowScale, transition: { duration: 0.3 } }, exit: { opacity: 0, scale: 0.8, transition: { duration: 0.2 } } };
  return (
    <div className="relative flex flex-col items-center gap-4">
      <div className="flex gap-2 p-1.5 rounded-full bg-card/50 border border-border/50 backdrop-blur-sm">
        {templates.map(({ id, icon: Icon, label }) => (<button key={id} onClick={() => setActiveTemplate(id)} className={`flex items-center gap-1.5 px-3 py-1.5 rounded-full text-xs font-medium transition-all ${activeTemplate === id ? 'bg-primary text-primary-foreground shadow-lg' : 'text-muted-foreground hover:text-foreground hover:bg-secondary'}`} title={label}><Icon className="w-3.5 h-3.5" /><span className="hidden sm:inline">{label}</span></button>))}
        <button onClick={handleRandomColor} className="flex items-center gap-1.5 px-3 py-1.5 rounded-full text-xs font-medium text-muted-foreground hover:text-foreground hover:bg-secondary transition-all" title="Random szín"><Shuffle className="w-3.5 h-3.5" /></button>
      </div>
      <div className="relative">
        <motion.div className="absolute -inset-10 opacity-70 blur-3xl pointer-events-none" animate={{ background: `radial-gradient(circle at top, ${state.glowSettings.baseColor}80, transparent 60%)` }} transition={{ duration: 0.5 }} />
        <div className="relative rounded-[2.4rem] bg-card/90 border border-border/80 shadow-[0_26px_80px_rgba(0,0,0,0.95)] p-2.5">
          <div className="relative w-[375px] h-[812px] rounded-[40px] overflow-hidden shadow-2xl border-4 transition-colors duration-500 bg-background border-border">
            <AnimatePresence>
              {state.powerOn && state.activeEffects.glow && (
                <Draggable nodeRef={nodeRef} position={{ x: dragX, y: dragY }} onDrag={handleDrag} onStart={() => setIsDragging(true)} onStop={() => setIsDragging(false)}>
                  <motion.div ref={nodeRef} variants={glowVariants} initial="initial" animate="animate" exit="exit" className={`absolute w-[1700px] h-[2400px] cursor-move z-[1] ${state.glowSettings.animation === 'pulse' ? 'animate-glow-pulse' : state.glowSettings.animation === 'breathe' ? 'animate-glow-breathe' : state.glowSettings.animation === 'wave' ? 'animate-glow-wave' : ''}`} style={{ maskImage: `linear-gradient(black ${maskSize * 100}%, transparent 100%)`, transition: isDragging ? 'none' : 'opacity 0.2s', left: `${defaultX}px`, top: `${defaultY}px`, '--glow-speed': `${state.glowSettings.animationSpeed}s` } as React.CSSProperties}>
                    <div className={`absolute top-[800px] left-[750px] flex items-center gap-2 px-3 py-1.5 rounded-full bg-black/50 backdrop-blur-sm border border-white/10 transition-opacity ${isDragging ? 'opacity-100' : 'opacity-0 hover:opacity-100'}`}><Move className="w-3 h-3 text-white/60" /><span className="text-[10px] text-white/60">Húzd a mozgatáshoz</span></div>
                    <motion.div className="absolute top-[400px] left-[300px] w-[1800px] rounded-full opacity-40 mix-blend-screen pointer-events-none" animate={{ backgroundColor: oklchColor }} transition={{ duration: 0.3 }} style={{ height: '1140px', filter: 'blur(180px)' }} />
                    <motion.div className="absolute top-[600px] left-[460px] w-[1300px] h-[1300px] rounded-full opacity-60 mix-blend-screen pointer-events-none" animate={{ backgroundColor: oklchColor }} transition={{ duration: 0.3 }} style={{ filter: 'blur(120px)' }} />
                    <motion.div className="absolute top-[700px] left-[560px] w-[1000px] h-[800px] rounded-full mix-blend-screen pointer-events-none" animate={{ backgroundColor: oklchColor }} transition={{ duration: 0.3 }} style={{ filter: 'blur(60px)', opacity: 1 }} />
                    <div className="absolute top-[800px] left-[700px] w-[600px] h-[440px] rounded-full mix-blend-normal pointer-events-none" style={{ backgroundColor: 'rgb(255, 255, 255)', filter: 'blur(80px)', opacity: 0.4 }} />
                  </motion.div>
                </Draggable>
              )}
            </AnimatePresence>
            {state.powerOn && state.activeEffects.glass && (<motion.div className="absolute inset-0 z-[2] pointer-events-none" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} style={glassStyle} />)}
            <AnimatePresence>{noiseEnabled && (<motion.div className="absolute inset-0 w-full h-full pointer-events-none z-[5] mix-blend-overlay" initial={{ opacity: 0 }} animate={{ opacity: noiseIntensity }} exit={{ opacity: 0 }} transition={{ duration: 0.3 }} style={{ backgroundImage: `url("${noiseUrl}")`, backgroundRepeat: 'repeat', backgroundSize: '200px 200px' }} />)}</AnimatePresence>
            {renderTemplate()}
            <a href="https://ap.cx" target="_blank" rel="noopener noreferrer" className="absolute bottom-2 left-1/2 -translate-x-1/2 text-[11px] z-10 opacity-50 hover:opacity-80 text-white/50 transition-opacity">ap.cx</a>
          </div>
        </div>
      </div>
    </div>
  );
};

```
```components/PhonePreviewTemplates.tsx
import { Paintbrush, User, Settings, Bell, CreditCard, TrendingUp, BarChart3, Calendar, Mail, Star, Heart, MessageCircle, Share2, MoreHorizontal, Image as ImageIcon, Play } from 'lucide-react';
export type PreviewTemplate = 'onboarding' | 'dashboard' | 'profile' | 'cards';
interface TemplateProps { getNeomorphShadow: () => React.CSSProperties; getClayStyle: () => React.CSSProperties; }
const mergeStyles = (neo: React.CSSProperties, clay: React.CSSProperties): React.CSSProperties => ({ ...neo, ...clay });
export const OnboardingTemplate = ({ getNeomorphShadow, getClayStyle }: TemplateProps) => (
  <div className="absolute bottom-0 w-full p-8 pb-12 flex flex-col gap-6 z-10">
    <div className="w-10 h-10 rounded-xl flex items-center justify-center cursor-pointer transition-colors" style={mergeStyles(getNeomorphShadow(), getClayStyle())}><Paintbrush className="w-5 h-5 text-white/80" /></div>
    <div><div className="text-xs font-medium tracking-widest uppercase mb-2 text-white/60">Collaboration Hub</div><h1 className="text-3xl font-bold leading-tight mb-4 text-white">Get More Done Together</h1><p className="text-sm leading-relaxed text-white/60">Stay aligned, share ideas, and keep every project moving smoothly.</p></div>
    <div className="flex flex-col gap-3 mt-4"><button className="w-full h-12 rounded-full flex items-center justify-center gap-3 font-medium text-black transition-colors" style={{ ...mergeStyles(getNeomorphShadow(), getClayStyle()), background: 'white' }}><span>Continue With Google</span></button><button className="w-full h-12 rounded-full flex items-center justify-center font-medium text-white/80 transition-colors" style={mergeStyles(getNeomorphShadow(), getClayStyle())}>Skip</button></div>
  </div>
);
export const DashboardTemplate = ({ getNeomorphShadow, getClayStyle }: TemplateProps) => (
  <div className="absolute inset-0 w-full h-full p-4 pt-12 flex flex-col gap-4 z-10 overflow-hidden">
    <div className="flex items-center justify-between"><div><p className="text-xs text-white/50">Good morning</p><h2 className="text-lg font-semibold text-white">Dashboard</h2></div><div className="flex gap-2"><div className="w-8 h-8 rounded-full bg-white/10 flex items-center justify-center"><Bell className="w-4 h-4 text-white/70" /></div><div className="w-8 h-8 rounded-full bg-white/10 flex items-center justify-center"><Settings className="w-4 h-4 text-white/70" /></div></div></div>
    <div className="grid grid-cols-2 gap-3"><div className="p-4 rounded-2xl" style={mergeStyles(getNeomorphShadow(), getClayStyle())}><div className="flex items-center gap-2 mb-2"><div className="w-6 h-6 rounded-lg bg-emerald-500/20 flex items-center justify-center"><TrendingUp className="w-3.5 h-3.5 text-emerald-400" /></div><span className="text-[10px] text-white/50">Revenue</span></div><p className="text-xl font-bold text-white">$24,560</p><span className="text-[10px] text-emerald-400">+12.5%</span></div><div className="p-4 rounded-2xl" style={mergeStyles(getNeomorphShadow(), getClayStyle())}><div className="flex items-center gap-2 mb-2"><div className="w-6 h-6 rounded-lg bg-violet-500/20 flex items-center justify-center"><BarChart3 className="w-3.5 h-3.5 text-violet-400" /></div><span className="text-[10px] text-white/50">Orders</span></div><p className="text-xl font-bold text-white">1,847</p><span className="text-[10px] text-violet-400">+8.2%</span></div></div>
    <div className="flex-1 rounded-2xl p-4" style={mergeStyles(getNeomorphShadow(), getClayStyle())}><div className="flex items-center justify-between mb-4"><span className="text-xs font-medium text-white/70">Performance</span><span className="text-[10px] text-white/40">Last 7 days</span></div><div className="flex items-end gap-2 h-32">{[40, 65, 45, 80, 55, 90, 70].map((h, i) => (<div key={i} className="flex-1 flex flex-col items-center gap-1"><div className="w-full rounded-t-md bg-gradient-to-t from-violet-500/50 to-cyan-500/50" style={{ height: `${h}%` }} /></div>))}</div></div>
    <div className="grid grid-cols-4 gap-2 pb-4">{[{ icon: Calendar, label: 'Calendar' }, { icon: Mail, label: 'Messages' }, { icon: CreditCard, label: 'Payments' }, { icon: MoreHorizontal, label: 'More' }].map(({ icon: Icon, label }) => (<div key={label} className="flex flex-col items-center gap-1"><div className="w-12 h-12 rounded-xl flex items-center justify-center" style={mergeStyles(getNeomorphShadow(), getClayStyle())}><Icon className="w-5 h-5 text-white/60" /></div><span className="text-[9px] text-white/40">{label}</span></div>))}</div>
  </div>
);
export const ProfileTemplate = ({ getNeomorphShadow, getClayStyle }: TemplateProps) => (
  <div className="absolute inset-0 w-full h-full flex flex-col z-10 overflow-hidden">
    <div className="h-40 bg-gradient-to-br from-violet-600/30 to-cyan-600/30 relative"><div className="absolute inset-0 bg-black/20" /></div>
    <div className="flex-1 px-6 -mt-16"><div className="w-24 h-24 rounded-2xl flex items-center justify-center mb-4 border-4 border-black" style={mergeStyles(getNeomorphShadow(), getClayStyle())}><User className="w-12 h-12 text-white" /></div><h2 className="text-xl font-bold text-white mb-1">Alex Morgan</h2><p className="text-xs text-white/50 mb-1">@alexmorgan</p><p className="text-sm text-white/70 mb-4">Digital designer & creative director. Making beautiful things since 2015.</p><div className="flex gap-6 mb-6"><div className="text-center"><p className="text-lg font-bold text-white">248</p><p className="text-[10px] text-white/40">Posts</p></div><div className="text-center"><p className="text-lg font-bold text-white">12.4k</p><p className="text-[10px] text-white/40">Followers</p></div><div className="text-center"><p className="text-lg font-bold text-white">892</p><p className="text-[10px] text-white/40">Following</p></div></div><div className="flex gap-3 mb-6"><button className="flex-1 h-10 rounded-full font-medium text-sm text-black" style={{...mergeStyles(getNeomorphShadow(), getClayStyle()), background: 'white'}}>Follow</button><button className="w-10 h-10 rounded-full flex items-center justify-center" style={mergeStyles(getNeomorphShadow(), getClayStyle())}><MessageCircle className="w-4 h-4 text-white/70" /></button><button className="w-10 h-10 rounded-full flex items-center justify-center" style={mergeStyles(getNeomorphShadow(), getClayStyle())}><Share2 className="w-4 h-4 text-white/70" /></button></div><div className="grid grid-cols-3 gap-1.5">{[1, 2, 3, 4, 5, 6].map((i) => (<div key={i} className="aspect-square rounded-lg bg-white/5 flex items-center justify-center border border-white/5"><ImageIcon className="w-6 h-6 text-white/20" /></div>))}</div></div>
  </div>
);
export const CardsTemplate = ({ getNeomorphShadow, getClayStyle }: TemplateProps) => (
  <div className="absolute inset-0 w-full h-full p-4 pt-12 flex flex-col gap-4 z-10 overflow-auto scrollbar-dark">
    <div className="flex items-center justify-between mb-2"><h2 className="text-lg font-semibold text-white">Discover</h2><div className="w-8 h-8 rounded-full bg-white/10 flex items-center justify-center"><Bell className="w-4 h-4 text-white/70" /></div></div>
    <div className="rounded-2xl p-4" style={{...mergeStyles(getNeomorphShadow(), getClayStyle()), background: 'linear-gradient(135deg, rgba(124, 58, 237, 0.3), rgba(8, 145, 178, 0.3))'}}><div className="flex items-center gap-3 mb-3"><div className="w-10 h-10 rounded-xl bg-white/20 flex items-center justify-center"><Star className="w-5 h-5 text-amber-400" /></div><div className="flex-1"><h3 className="text-sm font-semibold text-white">Featured</h3><p className="text-xs text-white/50">Top picks for you</p></div><div className="w-8 h-8 rounded-full bg-white/10 flex items-center justify-center"><Play className="w-4 h-4 text-white/70" /></div></div><p className="text-xs text-white/60 line-clamp-2">Explore curated content tailored to your interests and preferences.</p></div>
    {[{ title: 'Design Systems', subtitle: '24 articles', color: 'from-rose-500/20 to-orange-500/20' }, { title: 'Motion Design', subtitle: '18 tutorials', color: 'from-emerald-500/20 to-cyan-500/20' }, { title: 'Typography', subtitle: '32 resources', color: 'from-blue-500/20 to-violet-500/20' }].map((card, i) => (<div key={i} className={`rounded-2xl bg-gradient-to-br ${card.color} p-4 flex items-center gap-4`} style={mergeStyles(getNeomorphShadow(), getClayStyle())}><div className="w-16 h-16 rounded-xl bg-white/10 flex items-center justify-center"><ImageIcon className="w-8 h-8 text-white/30" /></div><div className="flex-1"><h3 className="text-sm font-semibold text-white mb-0.5">{card.title}</h3><p className="text-[10px] text-white/50">{card.subtitle}</p></div><div className="flex flex-col items-center gap-1"><Heart className="w-5 h-5 text-white/40" /><span className="text-[9px] text-white/30">142</span></div></div>))}
  </div>
);

```
```components/EffectEditorTabs.tsx
import { useEffects } from '@/contexts/ThemeContext';
import { Tabs, TabsContent, TabsList, TabsTrigger } from './ui/tabs';
import { GlowEditor } from './GlowEditor';
import { GlassEditor } from './GlassEditor';
import { NeomorphEditor } from './NeomorphEditor';
import { ClayEditor } from './ClayEditor';
import { HistoryTimeline } from './HistoryTimeline';
import { Sparkles, Square, Layers, Box, LucideIcon } from 'lucide-react';
import { useState, useMemo, memo } from 'react';
type EffectType = 'glow' | 'glass' | 'neomorph' | 'clay';
interface TabConfig { id: EffectType; label: string; icon: LucideIcon; colorClass: string; activeColorClass: string; Component: React.ComponentType; }
const TAB_CONFIG: readonly TabConfig[] = [
  { id: 'glow', label: 'Glow', icon: Sparkles, colorClass: 'amber', activeColorClass: 'data-[state=active]:bg-amber-500/20 data-[state=active]:text-amber-200', Component: GlowEditor },
  { id: 'glass', label: 'Glass', icon: Square, colorClass: 'sky', activeColorClass: 'data-[state=active]:bg-sky-500/20 data-[state=active]:text-sky-200', Component: GlassEditor },
  { id: 'neomorph', label: 'Neomorph', icon: Layers, colorClass: 'purple', activeColorClass: 'data-[state=active]:bg-purple-500/20 data-[state=active]:text-purple-200', Component: NeomorphEditor },
  { id: 'clay', label: 'Clay', icon: Box, colorClass: 'rose', activeColorClass: 'data-[state=active]:bg-rose-500/20 data-[state=active]:text-rose-200', Component: ClayEditor }
] as const;
const TabsContentWrapper = memo(({ children }: { children: React.ReactNode }) => (<div className="mt-4 bg-zinc-900/50 backdrop-blur-xl border border-white/10 rounded-3xl p-6">{children}</div>));
TabsContentWrapper.displayName = 'TabsContentWrapper';
export const EffectEditorTabs = memo(() => {
  const { state } = useEffects();
  const [activeTab, setActiveTab] = useState<EffectType>('glow');
  const ActiveEditorComponent = useMemo(() => { const activeConfig = TAB_CONFIG.find(tab => tab.id === activeTab); return activeConfig ? activeConfig.Component : null; }, [activeTab]);
  const renderTabTrigger = (config: TabConfig) => { const { id, label, icon: Icon, activeColorClass } = config; const isDisabled = !state.activeEffects[id]; return (<TabsTrigger key={id} value={id} className={`gap-1.5 text-xs ${activeColorClass}`} disabled={isDisabled}><Icon className="w-3.5 h-3.5" />{label}</TabsTrigger>); };
  return (<div className="w-full max-w-md flex flex-col gap-4"><Tabs value={activeTab} onValueChange={(value) => setActiveTab(value as EffectType)} className="w-full"><TabsList className="w-full grid grid-cols-4 bg-zinc-900/50 border border-zinc-800/80 h-11">{TAB_CONFIG.map(renderTabTrigger)}</TabsList><TabsContentWrapper><TabsContent value={activeTab} className="mt-0">{ActiveEditorComponent && <ActiveEditorComponent />}</TabsContent></TabsContentWrapper></Tabs><HistoryTimeline /></div>);
});
EffectEditorTabs.displayName = 'EffectEditorTabs';

```
```components/ExportPanel.tsx
import { useEffects } from '@/contexts/ThemeContext';
import { Copy, Download, Code, FileJson, Palette, Check, LucideIcon } from 'lucide-react';
import { useState, useMemo, useCallback, memo } from 'react';
import { toast } from '@/hooks/use-toast';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
type ExportFormat = 'css' | 'tailwind' | 'json';
interface TabConfig { value: ExportFormat; label: string; icon: LucideIcon; }
interface CodePreviewProps { code: string; format: ExportFormat; copiedFormat: ExportFormat | null; onCopy: (format: ExportFormat) => void; onDownload: (format: ExportFormat) => void; }
const TAB_CONFIG: readonly TabConfig[] = [ { value: 'css', label: 'CSS', icon: Palette }, { value: 'tailwind', label: 'Tailwind', icon: Code }, { value: 'json', label: 'JSON', icon: FileJson } ] as const;
const FILE_CONFIG: Record<ExportFormat, { filename: string; mimeType: string }> = { css: { filename: 'effect-styles.css', mimeType: 'text/css' }, tailwind: { filename: 'tailwind-effects.ts', mimeType: 'text/typescript' }, json: { filename: 'effect-settings.json', mimeType: 'application/json' } };
class EffectCodeGenerator {
  static generateGlowCSS(glowSettings: any, oklch: string): string { return `/* Glow Effect */\n.glow-effect {\n  background-color: ${oklch};\n  filter: blur(180px);\n  opacity: 0.6;\n  mix-blend-mode: screen;\n}\n.glow-container {\n  --glow-color: ${oklch};\n  --glow-base: ${glowSettings.baseColor};\n  position: relative;\n}\n`; }
  static generateGlassCSS(glassSettings: any): string { const hexOpacity = Math.round(glassSettings.opacity * 2.55).toString(16).padStart(2, '0'); return `/* Glass Effect */\n.glass-effect {\n  backdrop-filter: blur(${glassSettings.blur}px) saturate(${glassSettings.saturation}%);\n  background-color: ${glassSettings.tint}${hexOpacity};\n  border: ${glassSettings.borderWidth}px solid rgba(255, 255, 255, ${glassSettings.borderOpacity / 100});\n}\n`; }
  static generateNeomorphCSS(neomorphSettings: any): string { const { distance, blur, intensity, lightSource, surfaceColor, shape } = neomorphSettings; const angle = (lightSource * Math.PI) / 180; const lightX = Math.round(Math.cos(angle) * distance); const lightY = Math.round(Math.sin(angle) * distance); const darkX = -lightX; const darkY = -lightY; const lightOpacity = (intensity / 100 * 0.5).toFixed(2); const darkOpacity = (intensity / 100).toFixed(2); const inset = shape === 'pressed' || shape === 'concave' ? 'inset ' : ''; return `/* Neomorphism Effect */\n.neomorph-effect {\n  background-color: ${surfaceColor};\n  box-shadow: ${inset}${lightX}px ${lightY}px ${blur}px rgba(255, 255, 255, ${lightOpacity}),\n              ${inset}${darkX}px ${darkY}px ${blur}px rgba(0, 0, 0, ${darkOpacity});\n  border-radius: 16px;\n}\n`; }
  static generateClayCSS(claySettings: any): string { const { depth, spread, borderRadius, highlightColor, shadowColor, surfaceTexture, bendAngle } = claySettings; const gradientMap = { glossy: `linear-gradient(${135 + bendAngle}deg, ${highlightColor}40 0%, transparent 50%, ${shadowColor}20 100%)`, matte: `linear-gradient(${135 + bendAngle}deg, ${highlightColor}20 0%, transparent 100%)`, default: `linear-gradient(${135 + bendAngle}deg, ${highlightColor}30 0%, transparent 60%, ${shadowColor}10 100%)` }; const gradient = gradientMap[surfaceTexture as keyof typeof gradientMap] || gradientMap.default; return `/* Clay Effect */\n.clay-effect {\n  border-radius: ${borderRadius}px;\n  box-shadow: 0 ${depth}px ${spread}px ${shadowColor}99,\n              0 ${Math.round(depth * 0.5)}px ${Math.round(spread * 0.5)}px ${shadowColor}66;\n  background: ${gradient};\n}\n`; }
}
const CodePreview = memo<CodePreviewProps>(({ code, format, copiedFormat, onCopy, onDownload }) => (
  <div className="relative"><pre className="text-[10px] font-jetbrains bg-secondary/50 rounded-lg p-3 overflow-auto max-h-48 text-muted-foreground scrollbar-dark"><code>{code}</code></pre><div className="absolute top-2 right-2 flex gap-1.5"><button onClick={() => onCopy(format)} className="p-1.5 rounded-md bg-background/80 hover:bg-background border border-border/50 transition-colors">{copiedFormat === format ? (<Check className="w-3 h-3 text-emerald" />) : (<Copy className="w-3 h-3 text-muted-foreground" />)}</button><button onClick={() => onDownload(format)} className="p-1.5 rounded-md bg-background/80 hover:bg-background border border-border/50 transition-colors"><Download className="w-3 h-3 text-muted-foreground" /></button></div></div>
));
CodePreview.displayName = 'CodePreview';
export const ExportPanel = memo(() => {
  const { state, getOklchColor } = useEffects();
  const [copiedFormat, setCopiedFormat] = useState<ExportFormat | null>(null);
  const generateCSS = useCallback((): string => { const oklch = getOklchColor(); const { glowSettings, glassSettings, neomorphSettings, claySettings, activeEffects } = state; let css = `/* Generated Effect Styles */\n\n`; if (activeEffects.glow) css += EffectCodeGenerator.generateGlowCSS(glowSettings, oklch); if (activeEffects.glass) css += EffectCodeGenerator.generateGlassCSS(glassSettings); if (activeEffects.neomorph) css += EffectCodeGenerator.generateNeomorphCSS(neomorphSettings); if (activeEffects.clay) css += EffectCodeGenerator.generateClayCSS(claySettings); return css; }, [state, getOklchColor]);
  const generateTailwind = useCallback((): string => { const { glowSettings, glassSettings, neomorphSettings, claySettings, activeEffects } = state; let config = `// tailwind.config.ts extend section\n{\n  theme: {\n    extend: {\n      colors: {\n        effect: {\n          glow: '${glowSettings.baseColor}',\n          tint: '${glassSettings.tint}',\n          surface: '${neomorphSettings.surfaceColor}',\n          highlight: '${claySettings.highlightColor}',\n          shadow: '${claySettings.shadowColor}',\n        },\n      },\n`; if (activeEffects.glass) config += `      backdropBlur: {\n        effect: '${glassSettings.blur}px',\n      },\n`; config += `    },\n  },\n}`; return config; }, [state]);
  const generateJSON = useCallback((): string => { const { glowSettings, glassSettings, neomorphSettings, claySettings, activeEffects, blurSettings } = state; const exportData = { version: '1.0', activeEffects, glow: { ...glowSettings, oklch: getOklchColor() }, glass: glassSettings, neomorph: neomorphSettings, clay: claySettings, blurPosition: blurSettings }; return JSON.stringify(exportData, null, 2); }, [state, getOklchColor]);
  const generatedCode = useMemo(() => ({ css: generateCSS(), tailwind: generateTailwind(), json: generateJSON() }), [generateCSS, generateTailwind, generateJSON]);
  const copyToClipboard = useCallback(async (format: ExportFormat) => { try { await navigator.clipboard.writeText(generatedCode[format]); setCopiedFormat(format); setTimeout(() => setCopiedFormat(null), 2000); toast({ title: "Copied!", description: `${format.toUpperCase()} code copied to clipboard.` }); } catch { toast({ title: "Failed to copy", description: "Please try again.", variant: "destructive" }); } }, [generatedCode]);
  const downloadFile = useCallback((format: ExportFormat) => { const { filename, mimeType } = FILE_CONFIG[format]; const blob = new Blob([generatedCode[format]], { type: mimeType }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); toast({ title: "Downloaded!", description: `${filename} has been downloaded.` }); }, [generatedCode]);
  return (
    <div className="space-y-4"><div className="flex items-center gap-2 mb-4"><div className="p-2 rounded-lg bg-accent/10"><Code className="w-4 h-4 text-accent" /></div><div><h3 className="text-sm font-semibold text-foreground">Export Code</h3><p className="text-xs text-muted-foreground">CSS, Tailwind, or JSON</p></div></div><Tabs defaultValue="css" className="w-full"><TabsList className="w-full bg-secondary/50 border border-border/50 mb-3">{TAB_CONFIG.map(({ value, label, icon: Icon }) => (<TabsTrigger key={value} value={value} className="flex-1 gap-1.5 text-xs data-[state=active]:bg-primary/20 data-[state=active]:text-primary"><Icon className="w-3 h-3" />{label}</TabsTrigger>))}</TabsList>{TAB_CONFIG.map(({ value }) => (<TabsContent key={value} value={value} className="mt-0"><CodePreview code={generatedCode[value]} format={value} copiedFormat={copiedFormat} onCopy={copyToClipboard} onDownload={downloadFile} /></TabsContent>))}</Tabs><div className="flex gap-2"><button onClick={() => copyToClipboard('css')} className="flex-1 flex items-center justify-center gap-2 py-2 px-3 rounded-lg bg-secondary/50 hover:bg-secondary border border-border/50 text-muted-foreground hover:text-foreground transition-colors text-xs font-medium"><Copy className="w-3.5 h-3.5" />Copy CSS</button><button onClick={() => downloadFile('json')} className="flex-1 flex items-center justify-center gap-2 py-2 px-3 rounded-lg bg-primary/10 hover:bg-primary/20 border border-primary/20 text-primary transition-colors text-xs font-medium"><Download className="w-3.5 h-3.5" />Save Settings</button></div></div>
  );
});
ExportPanel.displayName = 'ExportPanel';

```
```hooks/useHistory.ts
import { useCallback, useEffect, useRef, useMemo } from 'react';
export interface HistoryEntry<T> { id: string; timestamp: number; label: string; state: T; }
export interface HistoryState<T> { past: HistoryEntry<T>[]; present: T; future: HistoryEntry<T>[]; }
export interface HistoryConfig { maxSize?: number; debounceMs?: number; enableKeyboardShortcuts?: boolean; }
export interface UseHistoryReturn<T> { canUndo: boolean; canRedo: boolean; undo: () => void; redo: () => void; jumpTo: (entryId: string) => void; clear: () => void; getStats: () => HistoryStats; }
export interface HistoryStats { pastCount: number; futureCount: number; totalSize: number; oldestTimestamp: number | null; newestTimestamp: number | null; }
interface KeyboardShortcutConfig { undo: string; redo: string[]; modifierKey: 'ctrl' | 'meta' | 'both'; }
const DEFAULT_CONFIG: Required<HistoryConfig> = { maxSize: 50, debounceMs: 300, enableKeyboardShortcuts: true };
const KEYBOARD_SHORTCUTS: KeyboardShortcutConfig = { undo: 'z', redo: ['z', 'y'], modifierKey: 'both' };
class IdGenerator { private static counter = 0; static generate(): string { const timestamp = Date.now(); const random = Math.random().toString(36).substring(2, 11); const count = this.counter++; return `${timestamp}-${count}-${random}`; } static reset(): void { this.counter = 0; } }
class HistoryValidator { static isValid<T>(history: HistoryState<T>): boolean { return Array.isArray(history.past) && Array.isArray(history.future) && history.present !== undefined; } static sanitize<T>(history: HistoryState<T>): HistoryState<T> { return { past: Array.isArray(history.past) ? history.past : [], present: history.present, future: Array.isArray(history.future) ? history.future : [] }; } }
class HistoryAnalyzer { static getStats<T>(history: HistoryState<T>): HistoryStats { const allEntries = [...history.past, ...history.future]; const timestamps = allEntries.map(e => e.timestamp).filter(Boolean); return { pastCount: history.past.length, futureCount: history.future.length, totalSize: allEntries.length, oldestTimestamp: timestamps.length > 0 ? Math.min(...timestamps) : null, newestTimestamp: timestamps.length > 0 ? Math.max(...timestamps) : null }; } static canUndo<T>(history: HistoryState<T>): boolean { return history.past.length > 0; } static canRedo<T>(history: HistoryState<T>): boolean { return history.future.length > 0; } static findEntryIndex<T>(entries: HistoryEntry<T>[], entryId: string): number { return entries.findIndex(e => e.id === entryId); } }
class HistoryOperations {
  static createEntry<T>(state: T, label: string): HistoryEntry<T> { return { id: IdGenerator.generate(), timestamp: Date.now(), label, state }; }
  static push<T>(history: HistoryState<T>, newState: T, label: string, maxSize: number): HistoryState<T> { const entry = this.createEntry(history.present, label); const newPast = [...history.past, entry]; const trimmedPast = newPast.length > maxSize ? newPast.slice(-maxSize) : newPast; return { past: trimmedPast, present: newState, future: [] }; }
  static undo<T>(history: HistoryState<T>): HistoryState<T> | null { if (!HistoryAnalyzer.canUndo(history)) return null; const previous = history.past[history.past.length - 1]; const newPast = history.past.slice(0, -1); const futureEntry = this.createEntry(history.present, 'Redo point'); return { past: newPast, present: previous.state, future: [futureEntry, ...history.future] }; }
  static redo<T>(history: HistoryState<T>): HistoryState<T> | null { if (!HistoryAnalyzer.canRedo(history)) return null; const next = history.future[0]; const newFuture = history.future.slice(1); const pastEntry = this.createEntry(history.present, 'Undo point'); return { past: [...history.past, pastEntry], present: next.state, future: newFuture }; }
  static jumpTo<T>(history: HistoryState<T>, entryId: string): HistoryState<T> | null { const pastIndex = HistoryAnalyzer.findEntryIndex(history.past, entryId); if (pastIndex === -1) return null; const targetEntry = history.past[pastIndex]; const newPast = history.past.slice(0, pastIndex); const skippedEntries = history.past.slice(pastIndex + 1); const currentEntry = this.createEntry(history.present, 'Current state'); return { past: newPast, present: targetEntry.state, future: [...skippedEntries, currentEntry, ...history.future] }; }
  static clear<T>(present: T): HistoryState<T> { return { past: [], present, future: [] }; }
}
class KeyboardShortcutManager { private static isModifierPressed(event: KeyboardEvent, config: KeyboardShortcutConfig): boolean { switch (config.modifierKey) { case 'ctrl': return event.ctrlKey && !event.metaKey; case 'meta': return event.metaKey && !event.ctrlKey; case 'both': return event.ctrlKey || event.metaKey; default: return false; } } static handleKeyDown(event: KeyboardEvent, handlers: { undo: () => void; redo: () => void; canUndo: boolean; canRedo: boolean; }, config: KeyboardShortcutConfig = KEYBOARD_SHORTCUTS): void { if (!this.isModifierPressed(event, config)) return; if (event.key.toLowerCase() === config.undo && !event.shiftKey) { event.preventDefault(); if (handlers.canUndo) handlers.undo(); return; } if ((event.key.toLowerCase() === config.undo && event.shiftKey) || config.redo.includes(event.key.toLowerCase())) { event.preventDefault(); if (handlers.canRedo) handlers.redo(); return; } } }
export const useKeyboardShortcuts = (undo: () => void, redo: () => void, canUndo: boolean, canRedo: boolean, enabled: boolean = true): void => { const handlersRef = useRef({ undo, redo, canUndo, canRedo }); useEffect(() => { handlersRef.current = { undo, redo, canUndo, canRedo }; }, [undo, redo, canUndo, canRedo]); useEffect(() => { if (!enabled) return; const handleKeyDown = (event: KeyboardEvent) => { KeyboardShortcutManager.handleKeyDown(event, handlersRef.current); }; window.addEventListener('keydown', handleKeyDown); return () => window.removeEventListener('keydown', handleKeyDown); }, [enabled]); };
export const pushToHistory = <T>(history: HistoryState<T>, newState: T, label: string, maxSize: number = DEFAULT_CONFIG.maxSize): HistoryState<T> => { if (!HistoryValidator.isValid(history)) { history = HistoryValidator.sanitize(history); } return HistoryOperations.push(history, newState, label, maxSize); };
export const undoHistory = <T>(history: HistoryState<T>): HistoryState<T> | null => { if (!HistoryValidator.isValid(history)) return null; return HistoryOperations.undo(history); };
export const redoHistory = <T>(history: HistoryState<T>): HistoryState<T> | null => { if (!HistoryValidator.isValid(history)) return null; return HistoryOperations.redo(history); };
export const jumpToHistory = <T>(history: HistoryState<T>, entryId: string): HistoryState<T> | null => { if (!HistoryValidator.isValid(history) || !entryId) return null; return HistoryOperations.jumpTo(history, entryId); };
export const getHistoryStats = <T>(history: HistoryState<T>): HistoryStats => { if (!HistoryValidator.isValid(history)) return { pastCount: 0, futureCount: 0, totalSize: 0, oldestTimestamp: null, newestTimestamp: null }; return HistoryAnalyzer.getStats(history); };
export const clearHistory = <T>(present: T): HistoryState<T> => HistoryOperations.clear(present);
export { HistoryValidator, HistoryAnalyzer, HistoryOperations, IdGenerator };

```
```lib/color-conversion.ts
function hexToRgb(hex: string) { const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); return result ? { r: parseInt(result[1], 16) / 255, g: parseInt(result[2], 16) / 255, b: parseInt(result[3], 16) / 255 } : null; }
function componentToHex(c: number) { const hex = Math.round(c * 255).toString(16); return hex.length === 1 ? "0" + hex : hex; }
function rgbToHex(r: number, g: number, b: number) { return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b); }
function sRgbToLinear(c: number) { return c > 0.04045 ? Math.pow((c + 0.055) / 1.055, 2.4) : c / 12.92; }
function linearToSRgb(c: number) { return c > 0.0031308 ? 1.055 * Math.pow(c, 1 / 2.4) - 0.055 : 12.92 * c; }
const M1 = [[0.4122214708, 0.5363325363, 0.0514459929], [0.2119034982, 0.6806995451, 0.1073969566], [0.0883024619, 0.2817188376, 0.6299787005]];
const M2 = [[0.2104542553, 0.7936177850, -0.0040720468], [1.9779984951, -2.4285922050, 0.4505937099], [0.0259040371, 0.7827717662, -0.8086757660]];
const InvM1 = [[4.0767416621, -3.3077115913, 0.2309699292], [-1.2684380046, 2.6097574011, -0.3413193965], [-0.0041960863, -0.7034186147, 1.7076147010]];
const InvM2 = [[1, 0.3963377774, 0.2158037573], [1, -0.1055613458, -0.0638541728], [1, -0.0894841775, -1.2914855480]];
function multiplyMatrix(matrix: number[][], v: number[]) { return [matrix[0][0] * v[0] + matrix[0][1] * v[1] + matrix[0][2] * v[2], matrix[1][0] * v[0] + matrix[1][1] * v[1] + matrix[1][2] * v[2], matrix[2][0] * v[0] + matrix[2][1] * v[1] + matrix[2][2] * v[2]]; }
export function rgbToOklch(r: number, g: number, b: number): { l: number; c: number; h: number } { const linR = sRgbToLinear(r); const linG = sRgbToLinear(g); const linB = sRgbToLinear(b); const [l, m, s] = multiplyMatrix(M1, [linR, linG, linB]); const l_ = Math.cbrt(l); const m_ = Math.cbrt(m); const s_ = Math.cbrt(s); const [L, a, b_] = multiplyMatrix(M2, [l_, m_, s_]); const C = Math.sqrt(a * a + b_ * b_); let H = Math.atan2(b_, a) * (180 / Math.PI); if (H < 0) H += 360; return { l: L, c: C, h: H }; }
export function oklchToRgb(l: number, c: number, h: number): { r: number; g: number; b: number } { const hRad = h * (Math.PI / 180); const a = c * Math.cos(hRad); const b_ = c * Math.sin(hRad); const [l_, m_, s_] = multiplyMatrix(InvM2, [l, a, b_]); const lLin = l_ * l_ * l_; const mLin = m_ * m_ * m_; const sLin = s_ * s_ * s_; const [linR, linG, linB] = multiplyMatrix(InvM1, [lLin, mLin, sLin]); let r = linearToSRgb(linR); let g = linearToSRgb(linG); let b = linearToSRgb(linB); r = Math.max(0, Math.min(1, r)); g = Math.max(0, Math.min(1, g)); b = Math.max(0, Math.min(1, b)); return { r, g, b }; }
export function hexToOklch(hex: string): { l: number; c: number; h: number } { const rgb = hexToRgb(hex); if (!rgb) return { l: 0, c: 0, h: 0 }; return rgbToOklch(rgb.r, rgb.g, rgb.b); }
export function oklchToHex(l: number, c: number, h: number): string { const rgb = oklchToRgb(l, c, h); return rgbToHex(rgb.r, rgb.g, rgb.b); }

```
```index.css
@import url('https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&family=Sora:wght@400;500;600;700&display=swap');
@tailwind base;
@tailwind components;
@tailwind utilities;
@layer base {
  :root {
    --background: 240 10% 4%;
    --foreground: 0 0% 95%;
    --card: 240 6% 10%;
    --card-foreground: 0 0% 95%;
    --popover: 240 6% 10%;
    --popover-foreground: 0 0% 95%;
    --primary: 262 83% 58%;
    --primary-foreground: 0 0% 100%;
    --secondary: 240 5% 16%;
    --secondary-foreground: 0 0% 90%;
    --muted: 240 5% 16%;
    --muted-foreground: 240 5% 65%;
    --accent: 173 80% 40%;
    --accent-foreground: 0 0% 100%;
    --destructive: 0 72% 51%;
    --destructive-foreground: 0 0% 100%;
    --border: 240 4% 16%;
    --input: 240 4% 16%;
    --ring: 262 83% 58%;
    --radius: 0.75rem;
    --violet: 262 83% 58%;
    --violet-glow: 262 90% 70%;
    --cyan: 173 80% 40%;
    --cyan-glow: 173 90% 55%;
    --rose: 350 89% 60%;
    --rose-glow: 350 95% 70%;
    --amber: 38 92% 50%;
    --amber-glow: 38 95% 60%;
    --emerald: 160 84% 39%;
    --emerald-glow: 160 90% 50%;
    --glow-amber: 38 92% 50%;
    --glow-sky: 199 89% 48%;
    --glow-purple: 262 83% 58%;
    --glow-rose: 350 89% 60%;
    --glow-cyan: 173 80% 40%;
  }
  * { @apply border-border; }
  body { @apply bg-background text-foreground font-outfit; }
}
@layer utilities {
  .glow-amber { box-shadow: 0 0 25px hsl(38 92% 50% / 0.55); }
  .glow-sky { box-shadow: 0 0 25px hsl(199 89% 48% / 0.55); }
  .glow-purple { box-shadow: 0 0 25px hsl(262 83% 58% / 0.55); }
  .glow-rose { box-shadow: 0 0 25px hsl(350 89% 60% / 0.55); }
  .glow-cyan { box-shadow: 0 0 25px hsl(173 80% 40% / 0.55); }
  .glass { @apply bg-white/5 backdrop-blur-xl border border-white/10; }
  .glass-strong { @apply bg-white/10 backdrop-blur-2xl border border-white/15; }
  .text-gradient-primary { background: linear-gradient(135deg, hsl(262 83% 58%), hsl(280 80% 65%)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
  .scrollbar-dark::-webkit-scrollbar { width: 6px; height: 6px; }
  .scrollbar-dark::-webkit-scrollbar-track { background: hsl(240 6% 10%); border-radius: 3px; }
  .scrollbar-dark::-webkit-scrollbar-thumb { background: hsl(240 5% 25%); border-radius: 3px; }
  .scrollbar-dark::-webkit-scrollbar-thumb:hover { background: hsl(240 5% 35%); }
  .preset-card { @apply relative overflow-hidden rounded-xl border border-border/50 bg-card/50 backdrop-blur-sm transition-all duration-300; }
  .preset-card:hover { @apply border-primary/50 shadow-lg; box-shadow: 0 0 30px hsl(262 83% 58% / 0.2); }
  @keyframes glow-pulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.6; transform: scale(0.95); } }
  @keyframes glow-breathe { 0%, 100% { opacity: 0.8; filter: blur(180px); } 50% { opacity: 1; filter: blur(150px); } }
  @keyframes glow-wave { 0% { transform: translateX(0) translateY(0); } 25% { transform: translateX(20px) translateY(-10px); } 50% { transform: translateX(0) translateY(-20px); } 75% { transform: translateX(-20px) translateY(-10px); } 100% { transform: translateX(0) translateY(0); } }
  .animate-glow-pulse { animation: glow-pulse var(--glow-speed, 2s) ease-in-out infinite; }
  .animate-glow-breathe { animation: glow-breathe var(--glow-speed, 3s) ease-in-out infinite; }
  .animate-glow-wave { animation: glow-wave var(--glow-speed, 4s) ease-in-out infinite; }
}
.font-outfit { font-family: 'Outfit', sans-serif; }
.font-sora { font-family: 'Sora', sans-serif; }
.font-jetbrains { font-family: 'JetBrains Mono', monospace; }

```
```tailwind.config.ts
import type { Config } from "tailwindcss";
export default {
  darkMode: ["class"],
  content: ["./pages/**/*.{ts,tsx}", "./components/**/*.{ts,tsx}", "./app/**/*.{ts,tsx}", "./src/**/*.{ts,tsx}"],
  prefix: "",
  theme: {
    container: { center: true, padding: "2rem", screens: { "2xl": "1400px" } },
    extend: {
      fontFamily: { outfit: ['Outfit', 'sans-serif'], sora: ['Sora', 'sans-serif'], jetbrains: ['JetBrains Mono', 'monospace'] },
      colors: {
        border: "hsl(var(--border))", input: "hsl(var(--input))", ring: "hsl(var(--ring))", background: "hsl(var(--background))", foreground: "hsl(var(--foreground))",
        primary: { DEFAULT: "hsl(var(--primary))", foreground: "hsl(var(--primary-foreground))" },
        secondary: { DEFAULT: "hsl(var(--secondary))", foreground: "hsl(var(--secondary-foreground))" },
        destructive: { DEFAULT: "hsl(var(--destructive))", foreground: "hsl(var(--destructive-foreground))" },
        muted: { DEFAULT: "hsl(var(--muted))", foreground: "hsl(var(--muted-foreground))" },
        accent: { DEFAULT: "hsl(var(--accent))", foreground: "hsl(var(--accent-foreground))" },
        popover: { DEFAULT: "hsl(var(--popover))", foreground: "hsl(var(--popover-foreground))" },
        card: { DEFAULT: "hsl(var(--card))", foreground: "hsl(var(--card-foreground))" },
        violet: { DEFAULT: "hsl(var(--violet))", glow: "hsl(var(--violet-glow))" },
        cyan: { DEFAULT: "hsl(var(--cyan))", glow: "hsl(var(--cyan-glow))" },
        rose: { DEFAULT: "hsl(var(--rose))", glow: "hsl(var(--rose-glow))" },
        amber: { DEFAULT: "hsl(var(--amber))", glow: "hsl(var(--amber-glow))" },
        emerald: { DEFAULT: "hsl(var(--emerald))", glow: "hsl(var(--emerald-glow))" },
        glow: { amber: "hsl(var(--glow-amber))", sky: "hsl(var(--glow-sky))", purple: "hsl(var(--glow-purple))", rose: "hsl(var(--glow-rose))", cyan: "hsl(var(--glow-cyan))" }
      },
      borderRadius: { lg: "var(--radius)", md: "calc(var(--radius) - 2px)", sm: "calc(var(--radius) - 4px)" },
      keyframes: {
        "accordion-down": { from: { height: "0" }, to: { height: "var(--radix-accordion-content-height)" } },
        "accordion-up": { from: { height: "var(--radix-accordion-content-height)" }, to: { height: "0" } },
        "glow-pulse": { "0%, 100%": { opacity: "1", transform: "scale(1)" }, "50%": { opacity: "0.6", transform: "scale(0.95)" } },
        "glow-breathe": { "0%, 100%": { opacity: "0.8", filter: "blur(180px)" }, "50%": { opacity: "1", filter: "blur(150px)" } },
        "glow-wave": { "0%": { transform: "translateX(0) translateY(0)" }, "25%": { transform: "translateX(20px) translateY(-10px)" }, "50%": { transform: "translateX(0) translateY(-20px)" }, "75%": { transform: "translateX(-20px) translateY(-10px)" }, "100%": { transform: "translateX(0) translateY(0)" } },
        "fade-in": { from: { opacity: "0", transform: "translateY(10px)" }, to: { opacity: "1", transform: "translateY(0)" } },
        "scale-in": { from: { transform: "scale(0.95)", opacity: "0" }, to: { transform: "scale(1)", opacity: "1" } }
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        "glow-pulse": "glow-pulse var(--glow-speed, 2s) ease-in-out infinite",
        "glow-breathe": "glow-breathe var(--glow-speed, 3s) ease-in-out infinite",
        "glow-wave": "glow-wave var(--glow-speed, 4s) ease-in-out infinite",
        "fade-in": "fade-in 0.3s ease-out",
        "scale-in": "scale-in 0.2s ease-out"
      }
    }
  },
  plugins: [require("tailwindcss-animate")]
} satisfies Config;

```
